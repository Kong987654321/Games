<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Score Four</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            touch-action: none;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            color: white;
            text-align: center;
            max-width: 280px;
        }
        #status {
            font-size: 18px;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .blue-turn { color: #4a9eff; }
        .red-turn { color: #ff4a4a; }
        .button-container {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #4a9eff;
            color: white;
            transition: all 0.3s;
            min-width: 60px;
        }
        button:hover:not(:disabled) {
            background: #357abd;
            transform: scale(1.05);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }
        #reset {
            background: #ff4a4a;
        }
        #reset:hover {
            background: #cc3838;
        }
        #instructions {
            margin-top: 8px;
            font-size: 11px;
            color: #ccc;
        }
        #rotation-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            color: white;
        }
        .rotation-title {
            font-size: 12px;
            margin-bottom: 6px;
            color: #ccc;
        }
        .rotation-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            align-items: center;
        }
        .rotation-label {
            width: 60px;
            font-size: 11px;
        }
        .rotate-btn {
            width: 40px;
            height: 40px;
            font-size: 18px;
            padding: 0;
            min-width: 40px;
        }
        
        @media (max-width: 768px) {
            #ui {
                bottom: 5px;
                left: 5px;
                padding: 8px;
                max-width: calc(50% - 15px);
                font-size: 12px;
            }
            #status {
                font-size: 14px;
                margin-bottom: 6px;
            }
            button {
                padding: 6px 8px;
                font-size: 12px;
                min-width: 50px;
            }
            #instructions {
                font-size: 9px;
                margin-top: 6px;
            }
            #rotation-controls {
                bottom: 5px;
                right: 5px;
                padding: 8px;
            }
            .rotation-title {
                font-size: 10px;
                margin-bottom: 4px;
            }
            .rotation-label {
                width: 50px;
                font-size: 9px;
            }
            .rotate-btn {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui">
        <div id="status" class="blue-turn">Blue's Turn</div>
        <div class="button-container">
            <button id="undo">Undo</button>
            <button id="redo">Redo</button>
            <button id="reset">New Game</button>
        </div>
        <div id="instructions">Click on a stick to drop a piece</div>
    </div>
    <div id="rotation-controls">
        <div class="rotation-title">Camera Rotation</div>
        <div class="rotation-row">
            <div class="rotation-label">Horizontal:</div>
            <button class="rotate-btn" id="rotate-left">←</button>
            <button class="rotate-btn" id="rotate-right">→</button>
        </div>
        <div class="rotation-row">
            <div class="rotation-label">Vertical:</div>
            <button class="rotate-btn" id="rotate-up">↑</button>
            <button class="rotate-btn" id="rotate-down">↓</button>
        </div>
        <div class="rotation-row">
            <div class="rotation-label">Zoom:</div>
            <button class="rotate-btn" id="zoom-in">+</button>
            <button class="rotate-btn" id="zoom-out">−</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, raycaster, mouse;
        let board = [];
        let currentPlayer = 'blue';
        let gameOver = false;
        let sticks = [];
        let history = [];
        let historyIndex = -1;
        let cameraAngle = 0;
        let cameraHeight = 8;
        let cameraDistance = 7;
        let rotationInterval = null;
        let isRotating = false;
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let isTouchDrag = false;

        const BOARD_SIZE = 4;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // Create base board
            const baseGeometry = new THREE.BoxGeometry(4.2, 0.3, 4.2);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x63451e });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -0.15;
            scene.add(base);

            // Initialize board state
            for (let x = 0; x < BOARD_SIZE; x++) {
                board[x] = [];
                for (let z = 0; z < BOARD_SIZE; z++) {
                    board[x][z] = [];
                }
            }

            createSticks();
            setupEventListeners();
            animate();
        }

        function createSticks() {
            const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4.0, 16);
            const stickMaterial = new THREE.MeshStandardMaterial({ color: 0xdbb672 });

            for (let x = 0; x < BOARD_SIZE; x++) {
                for (let z = 0; z < BOARD_SIZE; z++) {
                    const stick = new THREE.Mesh(stickGeometry, stickMaterial.clone());
                    const posX = (x - 1.5) * 1.0;
                    const posZ = (z - 1.5) * 1.0;
                    stick.position.set(posX, 2.0, posZ);
                    stick.userData = { x, z, type: 'stick' };
                    scene.add(stick);
                    sticks.push(stick);
                }
            }
        }

        function createPiece(x, y, z, color) {
            const geometry = new THREE.SphereGeometry(0.4, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: color === 'blue' ? 0x4a9eff : 0xff4a4a,
                metalness: 0.3,
                roughness: 0.4
            });
            const piece = new THREE.Mesh(geometry, material);
            const posX = (x - 1.5) * 1.0;
            const posY = y * 1.0 + 0.4;
            const posZ = (z - 1.5) * 1.0;
            piece.position.set(posX, posY, posZ);
            scene.add(piece);
            return piece;
        }

        function dropPiece(x, z) {
            if (gameOver) return false;
            
            const column = board[x][z];
            if (column.length >= BOARD_SIZE) return false;

            const y = column.length;
            const piece = createPiece(x, y, z, currentPlayer);
            column.push({ color: currentPlayer, mesh: piece });

            // Clear future history when making a new move
            history = history.slice(0, historyIndex + 1);
            history.push({ x, z, color: currentPlayer });
            historyIndex++;

            if (checkWin(x, y, z)) {
                gameOver = true;
                document.getElementById('status').textContent = `${currentPlayer === 'blue' ? 'Blue' : 'Red'} Wins!`;
                return true;
            }

            currentPlayer = currentPlayer === 'blue' ? 'red' : 'blue';
            updateStatus();
            return true;
        }

        function checkWin(x, y, z) {
            const color = currentPlayer;
            const directions = [
                [[1,0,0], [-1,0,0]], // X axis
                [[0,1,0], [0,-1,0]], // Y axis
                [[0,0,1], [0,0,-1]], // Z axis
                [[1,1,0], [-1,-1,0]], // XY diagonal
                [[1,0,1], [-1,0,-1]], // XZ diagonal
                [[0,1,1], [0,-1,-1]], // YZ diagonal
                [[1,1,1], [-1,-1,-1]], // XYZ diagonal
                [[1,1,-1], [-1,-1,1]], // XY-Z diagonal
                [[1,-1,1], [-1,1,-1]], // X-YZ diagonal
                [[-1,1,1], [1,-1,-1]], // -XYZ diagonal
            ];

            for (const [dir1, dir2] of directions) {
                let count = 1;
                count += countDirection(x, y, z, color, dir1);
                count += countDirection(x, y, z, color, dir2);
                if (count >= 4) return true;
            }
            return false;
        }

        function countDirection(x, y, z, color, [dx, dy, dz]) {
            let count = 0;
            let nx = x + dx, ny = y + dy, nz = z + dz;
            while (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && nz >= 0 && nz < BOARD_SIZE) {
                if (board[nx][nz][ny] && board[nx][nz][ny].color === color) {
                    count++;
                    nx += dx;
                    ny += dy;
                    nz += dz;
                } else {
                    break;
                }
            }
            return count;
        }

        function onMouseClick(event) {
            if (event.button !== 0 || isDragging) return; // Only left click and not if we were dragging
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(sticks);

            if (intersects.length > 0) {
                const stick = intersects[0].object;
                const { x, z } = stick.userData;
                dropPiece(x, z);
            }
        }

        function onMouseDown(event) {
            if (event.button === 0) { // Left click
                isDragging = false; // Start as false, will become true if moved
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) { // Left click
                isDragging = false;
            }
        }

        function onMouseMove(event) {
            if (event.buttons === 1) { // Left mouse button is down
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;
                
                // If we've moved enough, consider it a drag
                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    isDragging = true;
                    cameraAngle += deltaX * 0.01;
                    cameraHeight = Math.max(3, Math.min(12, cameraHeight + deltaY * 0.05));
                    updateCameraPosition();
                }

                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(sticks);

            sticks.forEach(stick => {
                stick.material.color.setHex(0xdbb672);
            });

            if (intersects.length > 0 && !gameOver) {
                const stick = intersects[0].object;
                if (board[stick.userData.x][stick.userData.z].length < BOARD_SIZE) {
                    stick.material.color.setHex(currentPlayer === 'blue' ? 0x4a9eff : 0xff4a4a);
                }
            }
        }

        function updateStatus() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = `${currentPlayer === 'blue' ? 'Blue' : 'Red'}'s Turn`;
            statusEl.className = currentPlayer === 'blue' ? 'blue-turn' : 'red-turn';
            updateButtons();
        }

        function updateButtons() {
            document.getElementById('undo').disabled = historyIndex < 0;
            document.getElementById('redo').disabled = historyIndex >= history.length - 1;
        }

        function undo() {
            if (historyIndex < 0) return;

            const move = history[historyIndex];
            const column = board[move.x][move.z];
            const piece = column.pop();
            scene.remove(piece.mesh);

            historyIndex--;
            currentPlayer = move.color;
            gameOver = false;
            updateStatus();
        }

        function redo() {
            if (historyIndex >= history.length - 1) return;

            historyIndex++;
            const move = history[historyIndex];
            const column = board[move.x][move.z];
            const y = column.length;
            const piece = createPiece(move.x, y, move.z, move.color);
            column.push({ color: move.color, mesh: piece });

            if (checkWin(move.x, y, move.z)) {
                gameOver = true;
                document.getElementById('status').textContent = `${move.color === 'blue' ? 'Blue' : 'Red'} Wins!`;
            } else {
                currentPlayer = move.color === 'blue' ? 'red' : 'blue';
            }
            updateStatus();
        }

        function reset() {
            // Remove all pieces
            for (let x = 0; x < BOARD_SIZE; x++) {
                for (let z = 0; z < BOARD_SIZE; z++) {
                    board[x][z].forEach(piece => scene.remove(piece.mesh));
                    board[x][z] = [];
                }
            }

            currentPlayer = 'blue';
            gameOver = false;
            history = [];
            historyIndex = -1;
            updateStatus();
        }

        function setupEventListeners() {
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            document.getElementById('undo').addEventListener('click', undo);
            document.getElementById('redo').addEventListener('click', redo);
            document.getElementById('reset').addEventListener('click', reset);
            
            // Mouse down/up for hold-to-rotate
            document.getElementById('rotate-left').addEventListener('mousedown', () => startRotation(-1, 0, 0));
            document.getElementById('rotate-left').addEventListener('mouseup', stopRotation);
            document.getElementById('rotate-left').addEventListener('mouseleave', stopRotation);
            
            document.getElementById('rotate-right').addEventListener('mousedown', () => startRotation(1, 0, 0));
            document.getElementById('rotate-right').addEventListener('mouseup', stopRotation);
            document.getElementById('rotate-right').addEventListener('mouseleave', stopRotation);
            
            document.getElementById('rotate-up').addEventListener('mousedown', () => startRotation(0, 1, 0));
            document.getElementById('rotate-up').addEventListener('mouseup', stopRotation);
            document.getElementById('rotate-up').addEventListener('mouseleave', stopRotation);
            
            document.getElementById('rotate-down').addEventListener('mousedown', () => startRotation(0, -1, 0));
            document.getElementById('rotate-down').addEventListener('mouseup', stopRotation);
            document.getElementById('rotate-down').addEventListener('mouseleave', stopRotation);
            
            document.getElementById('zoom-in').addEventListener('mousedown', () => startRotation(0, 0, -1));
            document.getElementById('zoom-in').addEventListener('mouseup', stopRotation);
            document.getElementById('zoom-in').addEventListener('mouseleave', stopRotation);
            
            document.getElementById('zoom-out').addEventListener('mousedown', () => startRotation(0, 0, 1));
            document.getElementById('zoom-out').addEventListener('mouseup', stopRotation);
            document.getElementById('zoom-out').addEventListener('mouseleave', stopRotation);
            
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            cameraDistance += event.deltaY * zoomSpeed * 0.01;
            cameraDistance = Math.max(4, Math.min(15, cameraDistance));
            updateCameraPosition();
        }

        function startRotation(horizontal, vertical, zoom) {
            if (isRotating) return;
            isRotating = true;
            
            // Immediate rotation on click
            rotateCamera(horizontal, vertical, zoom);
            
            // Continue rotating while held
            rotationInterval = setInterval(() => {
                rotateCamera(horizontal, vertical, zoom);
            }, 50);
        }

        function stopRotation() {
            isRotating = false;
            if (rotationInterval) {
                clearInterval(rotationInterval);
                rotationInterval = null;
            }
        }

        function rotateCamera(horizontal, vertical, zoom) {
            if (horizontal !== 0) {
                cameraAngle += horizontal * 0.05;
            }
            if (vertical !== 0) {
                cameraHeight = Math.max(3, Math.min(12, cameraHeight + vertical * 0.15));
            }
            if (zoom !== 0) {
                cameraDistance += zoom * 0.1;
                cameraDistance = Math.max(4, Math.min(15, cameraDistance));
            }
            updateCameraPosition();
        }

        function updateCameraPosition() {
            const x = Math.cos(cameraAngle) * cameraDistance;
            const z = Math.sin(cameraAngle) * cameraDistance;
            camera.position.set(x, cameraHeight, z);
            camera.lookAt(0, 2, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                isTouchDrag = false;
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                previousMouseX = touchStartX;
                previousMouseY = touchStartY;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const deltaX = touch.clientX - previousMouseX;
                const deltaY = touch.clientY - previousMouseY;
                
                // If moved more than threshold, it's a drag
                if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
                    isTouchDrag = true;
                    cameraAngle += deltaX * 0.01;
                    cameraHeight = Math.max(3, Math.min(12, cameraHeight + deltaY * 0.05));
                    updateCameraPosition();
                }

                previousMouseX = touch.clientX;
                previousMouseY = touch.clientY;
            } else if (event.touches.length === 2) {
                // Pinch to zoom
                isTouchDrag = true;
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (this.lastTouchDistance) {
                    const delta = this.lastTouchDistance - currentDistance;
                    cameraDistance += delta * 0.01;
                    cameraDistance = Math.max(4, Math.min(15, cameraDistance));
                    updateCameraPosition();
                }
                
                this.lastTouchDistance = currentDistance;
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            
            if (!isTouchDrag && event.changedTouches.length === 1) {
                const touch = event.changedTouches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(sticks);

                if (intersects.length > 0) {
                    const stick = intersects[0].object;
                    const { x, z } = stick.userData;
                    dropPiece(x, z);
                }
            }
            
            isTouchDrag = false;
            this.lastTouchDistance = null;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
